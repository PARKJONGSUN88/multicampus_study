##############################################################
산점도(scatter plot) : 두 개 이상의 변수들 사이의 분포를 점으로 표시한 차트
두 변수의 관계를 시각적으로 분석할 때 유용
##############################################################
price <- runif(10, min=1, max=100)
print(price)
plot(price, col="red")
par(new=T) #차트 추가
line_chart=1:100
#x축은 생성된 난수의 순서,  y축은 
plot(line_chart, type="l", col="red", axes=F, ann=F) #대각선 추가 

#좌표평면상의 점 등을 선으로 연결
par(mfrow=c(2, 2))
plot(price, type="l")  #실선
plot(price, type="o")  #원형과 실선
plot(price, type="h")  #직선
plot(price, type="s")  #꺽은선

#중복된 데이터의 수만큼 plot점 크기 확대
x<-c(1, 2, 3, 4, 2, 4)
y<-rep(2, 6)
table(x, y)  #빈도수


par(mfrow=c(1, 1))
plot(x, y)

xy.df <- as.data.frame(table(x, y))
xy.df

plot(x, y, pch='@', col='blue', cex=0.5*xy.df$Freq, 
         xlab="x벡터 원소", ylab="y벡터 원소")


install.packages("psych")
library(psych)
data(galton)

#child컬럼, parent컬럼을 대상으로 교차테이블을 생성 결과를 데이터프레임으로 생성
galtondf <- as.data.frame(table(galton$child, galton$parent))
head(galtondf)
str(galtondf)

names(galtondf) <-c("child", "parent", "freq")
head(galtondf)
parent <- as.numeric(galtondf$parent)
child <- as.numeric(galtondf$child)

plot(parent, child, pch=21, col="blue", bg="green", 
     cex=0.2*galtondf$freq, xlab="parent", ylab="child")

#################################################
#pairs() : 변수 간의 관계를 차트로 그릴 수 있다
graphics패키지에서 제공하는 paris()는 matrix 또는 data.frame의 
numeric 컬럼을 대상으로 변수들 사이의 비교 결과를 행렬구조의
분산된 그래프로 제공합니다.
#################################################
attributes(iris)  #

pairs(iris[, 1:4])
pairs(iris[iris$Species=="setosa", 1:4])

#####################################################
3차원 산점도
scatterplot3d(밑변, 오른쪽변 컬럼명, 왼쪽변 컬럼명)
#####################################################
install.packages("scatterplot3d")
library(scatterplot3d)
levels(iris$Species)
iris_setosa = iris[iris$Species=='setosa', ]
iris_versicolor = iris[iris$Species=='versicolor', ]
iris_virginica = iris[iris$Species=='virginica', ]
d3 <- scatterplot3d(iris$Petal.Length, iris$Sepal.Length,
      iris$Sepal.Width, type='n')  #type='n'은 기본 산점도를 표시하지 않음

d3$points3d(iris_setosa$Petal.Length, iris_setosa$Sepal.Length ,
            iris_setosa$Sepal.Width, bg="orange", pch=21)

d3$points3d(iris_versicolor$Petal.Length, iris_versicolor$Sepal.Length ,
            iris_versicolor$Sepal.Width, bg="blue", pch=23)

d3$points3d(iris_virginica$Petal.Length, iris_virginica$Sepal.Length ,
            iris_virginica$Sepal.Width, bg="green", pch=25)

##################################################################
데이터 분석 프로젝트에서는 70%이상의 시간을 데이터 변환과 
조작, 필터링 등 전처리 작업에 소요됩니다.
데이터 전처리에 사용되는 유용한 패키지 : plyr, dplyr, reshape, reshape2패키지
####################################################################
# plyr 패키지는 두개 이상의 데이터프레임을 대상으로 key값을 이용하여
 merge, 함수적용 , 요약 집계등의 기능을 제공합니다.
install.packages("plyr")
library(plyr)
x<-data.frame(id=c(1,2,3,4,5), 
              height=c(160, 171, 173, 162, 165))
y<-data.frame(id=c(5, 1, 3, 2, 4), 
              weight=c(55, 73, 60, 57, 75))

# join() : 두 데이터프레임을 merge
xyjoin <- join(x, y, by="id")
xyjoin

x<-data.frame(id=c(1,2,3,4,6), 
              height=c(160, 171, 173, 162, 165))
leftjoin <- join(x, y, by="id")   #왼쪽 데이터 프레임의 키값을 기준으로 merge
leftjoin    #키에 join할 데이터가 없으면 NA로 출력


innerjoin <- join(x, y, by="id", type="inner")
innerjoin   #innerjoin은 두 데이터프레임에서 키값이 있는 경우에만 조인을 수행


fulljoin <- join(x, y, by="id", type="full")
fulljoin   #키 값이 존재하는 전체 관측치를 대상으로 조인 수행, 키에 join할 데이터가 없으면 NA로 출력


x<-data.frame(key1=c(1,1, 2,2, 3), 
              key2=c('a', 'b', 'c','d', 'e'),
              val1 = c(10,20,30,40,50))

y<-data.frame(key1=c(3, 2, 2, 1, 1), 
              key2=c('e', 'd', 'c','b', 'a'),
              val1 = c(500,300,400,100,200))

xyjoin <- join (x, y, by=c('key1', 'key2'))
xyjoin


#apply(vec, func) - 결과는 벡터, 배열, 리스트
#lapply(vec|list, func) - 결과는  리스트
#sapply(vec , func) - 결과는 벡터, 배열, 행렬 반환
#tapply() - 데이터 셋에 집단 변수(이산형 범주)를 대상으로 그룹별 함수 적용
#tapply(vec, 집단변수, 함수)

names(iris)
unique(iris$Species)
tapply(iris$Sepal.Length, iris$Species, mean)
sd_iris <- tapply(iris$Sepal.Length, iris$Species, sd)
str(sd_iris)


#ddply() - 데이터 셋에 집단 변수(이산형 범주)를 대상으로 그룹별 함수를 여러개  적용할 수 있습니다.
#ddply(데이터 셋, 집단변수, 요약집계, 컬럼명=함수(변수)) - 결과를 data.frame타입으로 반환

avg_df <- ddply(iris, .(Species), summarise, avg=mean(Sepal.Length))
avg_df
str(avg_df)

result <-ddply(iris, .(Species), summarise, avg=mean(Sepal.Length)
                 , std = sd(Sepal.Length), max=max(Sepal.Length),
                  min=min(Sepal.Length))
result
str(result)



exam.csv#################################################################
id,class,math,english,science
1,1,50,98,50
2,1,60,97,60
3,1,45,86,78
4,1,30,98,58
5,2,25,80,65
6,2,50,89,98
7,2,80,90,45
8,2,90,78,25
9,3,20,98,15
10,3,50,98,45
11,3,65,65,65
12,3,45,85,32
13,4,46,98,65
14,4,48,87,12
15,4,75,56,78
16,4,58,98,65
17,5,65,68,98
18,5,80,78,90
19,5,89,68,87
20,5,78,83,58

############################################################
dplyr 패키지 -데이터 전처리( 조건 필터, 그룹핑,  함수적용, 변환, 집계연산, 정렬,.....)
filter() 조건에 맞는 데이터셋 추출, 행추출
filter(dataframe, 조건1, 조건2)
select() 데이터 셋을 대상으로 컬럼을 선택하는 기능
select(dataframe, 컬럼1, 컬럼2,...)
mutate() 데이터 넷의 새로운 컬럼을 추가하는 기능
mutate(dataframe, 컬럼명1=표현식, 컬럼명2=표현식, ...)
arrange() 데이터 셋의 특정 컬럼으로 정렬하는 기능
arrange(dataframe,컬럼, desc(컬럼), ...)
summarise() 데이터 셋의 특정 컬럼으로 요약집계 기능
summarise(dataframe, 추가컬럼명=함수(컬럼명), ....)
tbl_df() 데이터셋에서 콘솔 창의 크기만큼 데이터 셋 추출 기능
group_by(dataframe, 집단변수)
##########################################################
install.packages("dplyr")
library("dplyr")

exam <-                               #exam.csv파일읽어와서 저장
print(exam)
str(exam)

# %>% 파이프 연산자 (다음 함수의 입력값으로 전달)
# class가 1인 record(행)추출
class1 <- exam %>% filter(class==1)
print(class1)

# class가 1을 제외한 record(행)추출
other_class <- exam %>% filter(class!=1)
print(other_class)

#class가 1이면서 수학점수는 50이상인 행을 추출
class1_math50 <- exam %>% filter(class==1 & math>50 )
print(class1_math50)

#class가 1,3,5인 행만 추출
odd_class <- exam %>% filter(class  %in% c(1, 3, 5) )
print(odd_class)

#영어점수 컬럼값만 추출
e_jumsu <- exam %>% select(english)
print(e_jumsu)

#수학점수 제외하고 모든 컬럼 추출
all_column <- exam %>% select(-math)
print(all_column)

#class가 1이면서 영어점수 컬럼값만 1행에서~3행까지 출력
print(exam %>% filter(class==1)  %>% select(english) %>% head(3))
  
#수학점수를 기준으로 오름차순 정렬된 결과를 변수에 저장하고 출력
asc_math <- exam  %>%  arrange(math) 
print(asc_math)

#수학점수를 기준으로 내림차순 정렬된 결과를 변수에 저장하고 출력
desc_math <- exam  %>%  arrange(desc(math))
print(desc_math)

# 1차 정렬은 class의 오름차순, 2차 정렬은 수학점수의 내림차순으로 정렬
order_math <- exam  %>%  arrange(class, desc(math))
print(order_math)

#총점(수학+영어+과학) 열을 추가
new_exam <- exam %>% mutate(total= math+english+science) 
print( new_exam )

#평균 열 추가
avg_exam <- exam  %>% mutate(total= math+english+science, 
                      mean=(math+english+science)/3 ) 
print( avg_exam )


#pass이름의 열을 추가 (평균이 60점이상이면 "pass"값, 
                      60점미만이면 "fail"값을 가짐)
pass <-  exam  %>% mutate(mean=(math+english+science)/3)   
           %>% mutate(pass=ifelse(mean >= 60 , "pass", "fail" ) ) 
print( pass )


#추가된 평균 컬럼으로 내림차순 정렬
avg_desc_exam <-   pass %>% arrange( desc(mean))
print( avg_desc_exam)


install.packages("hflights")
library(hflights)
#2011년도 미국 휴스턴 출발 모든 비행기의 이착률 정보 기록
#대략 22만건, 21개의 변수(컬럼)로 구성된 데이터셋
str(hflights)
flights_df <- tbl_df(flights) #현재 R콘솔 창크기에서 볼수 있는 만큼 10개행? 8개 컬럼?
flights_df

#hflights데이터셋으로부터 1월의 2일 모든 비행기의 이착률 정보 추출
filter(hflights, Month==1 & DayofMonth==2)

#hflights데이터셋을 년, 월, 출발시간, 도착시간순으로 오름차순 정렬
arrange(hflights, Year, Month, DepTime, ArrTime)

#hflights데이터셋을 년(오름차순), 월(오름차순), 출발시간(내림차순), 도착시간(오름차순) 정렬
arrange(hflights, Year, Month, desc(DepTime), ArrTime)

#hflights데이터셋으로부터 년, 월, 출발시간, 도착시간 컬럼만 검색
select(hflights,Year, Month, DepTime, ArrTime)

#hflights데이터셋으로부터 출발지연시간과 도착지연시간과의 차이를 계산한 컬럼 추가
select(mutate(hflights, gain=ArrDelay-DepDelay,
                 gain_per_hour = gain(AirTime/60)), 
       Year, Month, ArrDelay, DepDelay, gain, gain_per_hour)


#hflights데이터셋으로부터 도착 시간에 대한 평균, 표준편차 계산
summarise(hflights, cnt=n(), delay=mean(AirTime, na.rm=T))
summarise(hflights, arrTimeSd = sd(AirTime, na.rm=T),
          arrTimeVar = var(AirTime, na.rm=T))


exam <-read.csv("./data/exam.csv")
print(exam)
summary_exam <- exam %>% summarise(mean_math=mean(math), 
                                       sum_math=sum(math),
                                       median_math =median(math),
                                       sd_math=sd(math),
                                       min_math=min(math),
                                       max_math=max(math),
                                       n=n()) 
print(summary_exam)
#그룹핑 : group_by()
#클래스별로 기초통계값을 출력
group_summary  <- exam %>% group_by(class) %>% summarise(mean_math=mean(math), 
                                       sum_math=sum(math),
                                       median_math =median(math),
                                       sd_math=sd(math),
                                       min_math=min(math),
                                       max_math=max(math),
                                       n=n())
print(group_summary)



install.packages("ggplot2")
library(ggplot2)
#자동차 배기량에 따라 고속도록 연비 ...데이터 셋
mpg <- as.data.frame(ggplot2::mpg)
print(mpg)
str(mpg)
#displ 배기량
#manufaturer 제조사
#cty 도시연비
#hwy 고속도로 연비
#class차종
library(dplyr)
Quiz> 회사별로 분리, suv 추출, 통합 연비(도시연비+고속도로 연비) 변수 생성, 
통합 연비 평균 산출, 내림차순 정렬, 1~5위까지 출력
 mpg %>% group_by(manufacturer) %>% filter(class="suv")
     %>% mutate(tot=(cty+hwy)/2) %>% summarise(mean_tot=mean(tot))
     %>% arrange(desc(mean_tot)) %>% head(5)


Quiz> 어떤 회사에서 "compact"(경차) 차종을 가장 많이 생산하는지 알아보려고 합니다. 
각 회사별로 "compact" 차종을 내림차순으로 정렬해 출력하세요
result <- mpg %>% filter(class="compact") %>% group_by(manufacturer)
         %>% summarise(count=n()) 
result %>% arrange(desc(count)) 
  

#######################################################################
OracleDB로부터 R실행환경(메모리)로 데이터 가져오기
RJDBC::JDBC("driver이름", "driver가 존재하는 클래스경로", "DB에서 문자열 처리")
dbConnect(driver객체, DB_Url, user, password)
dbGetQuery(connection객체,  select sql문장)
#######################################################################
install.packages("RJDBC")
library(RJDBC)
library(rJava)

drv <- JDBC("oracle.jdbc.OracleDriver",
             classPath="C:/app/student/product/11.2.0/dbhome_1/jdbc/lib/ojdbc6.jar",
             identifier.quote="'")

con <- dbConnect(drv, "jdbc:oracle:thin:@localhost:1521:orcl", "hr", "oracle")
rs <- dbGetQuery(con, "select tname from tab")
View(rs)

#############################################
관계도 : igraph()
############################################
install.packages("igraph")
library(igraph)
g1 <- graph(c(1, 2, 2, 3, 2, 4, 1, 4, 5, 5, 3, 6))
print(g1)
plot(g1)
str(g1)


name<-c("세종대왕", "일지매 부장", "김유신 과장", "손흥민 대리", "류현진 대리"
       "이순신 부장", "유관순 차장", "신사임당 대리", "강감찬 부장"
       , "광개토 과장", "정몽주 대리")
pemp <- c("세종대왕", "세종대왕", "일지매 부장" , "김유신 과장", "김유신 과장",
       "세종대왕",  "이순신 부장", "유관순 차장",  "세종대왕" , "강감찬 부장"
       , "광개토 과장")

emp <- data.frame(이름=name, 상사이름=pemp)
print(emp)
g <- graph.data.frame(emp, direct=T)
plot(g, layout=layout.fruchterman.reingold,
     vertex.size=8, edge.arrow.size=0.5)

################################################################
reshape 패키지
데이터 셋의 구성이 구분변수(identifier variable)에 의해서 특정 변수가 분류된 경우 
데이터 셋의 모댱을 변경하는 패키지
구분변수(identifier variable) : 데이터 셋에 1개 이상으로 분류되는 집단변수
측정변수(measured variable): 구분변수에 의해서 구분되는 변수

#데이터 파일을 가져오는 경우 컬럼명이 없으면 기본적으로 V1, V2, V3...
형식으로 기본 컬럼명이 적용되므로 데이터 셋의 컬럼명을 변경하려면
rename() 함수를 사용합니다.

#reshape(), melt() : 구분변수를 기분으로 측정변수를 분류하여 새로운
 컬럼을 생성
reshape(data.frame, varying="반복되는 측정 색인",
        v.names="반복되는 측정값", timevar="반복되는 측정 시간",
        idvar="1개 이상의 값으로 분류되는 변수", direction="wide/long")
#wide는 기준변수와 관련 변수가 1:n 관계로 관측치가 구성
#long은 기준변수와 관련 변수가 1:1 관계로 관측치가 구성
################################################################
install.packages("reshape")
library(reshape)


result <- read.csv("./data/reshape.csv", header=FALSE)
head(result) 

result <- rename(result, c(V1="total", v2="num1", v3="num2", V4="num3"))


data('Indometh')  #항염증제에 대한 약물동태학에 관한 데이터 셋
str(Indometh)  #생체내에서 약물의 흡수, 분포, 비축, 대사, 배설의 과정을 연구
                #Subject(실험대상), time(약물 투여시간:hr), conc(농도:ml/mcg)
Indometh   #long형식

# 기준변수 : timevar="time", idvar="Subject"
# 관측변수 : v.names="conc"
# 실험대상1을 기준으로 약물투여시간 0.25에서 8까지의 ...농도를 
wide <- reshape(Indometh, v.names="conc", timevar="time", idvar="Subject", direction="wide")
wide

reshape(wide, direction="long")

#varying="반복되는 측정 색인" 사용
long <- reshape(wide, idVar="Subject", varying=2:12,
                v.names="conc",  direction="long" )
str(long)

#melt(data, id="기준변수", measured="측정변수")
#melt는 구분변수를 기준으로 측정변수를 긴형식에서 넓은 형식으로 변경

smiths
#기준변수 ("subject", "time")를 이용하여 측정변수 분류
melt(smiths, id=c("subject", "time")) 

melt(smiths, id=c("subject", "time"), measured=c("age"))

melt(smiths, id=c("subject", "time"), measured=c("age", "weight", "height"))

melt(smiths, id=c(1:2), na.rm=T)
 

#cast() : 측정변수에 집합함수를 적용
#cast(data, 포뮬러 식 , ~측정변수, 집합함수)
smithsm <- melt(smiths, id=c(1:2))
smithsm
                 
cast(smithsm, subject= ~ variable) #subject와 time 변수를 이용하여 측정변수(age, weight, height)를 분류



#Indometh 데이터셋으로부터 subject와 time을 구분변수로 long 형식으로 변환


#Indometh 데이터셋으로부터 subject구분변수로 특정변수 농도의 합계 통계량 계산


#Indometh 데이터셋으로부터 subject구분변수로 특정변수 농도의 평균, 최소값~최대값 범위를 계산




##############################################
게임 매상 감소 원인 분석
##############################################
 
 
# CSV 파일을 읽어들이기
dau <- read.csv("./data/dau.csv", header = T, stringsAsFactors = F)
head(dau)
dpu <- read.csv("./data/dpu.csv", header = T, stringsAsFactors = F)
head(dpu)
install <- read.csv("./data/install.csv", header = T, stringsAsFactors= F)
head(install)


# DAU 데이터에 Install 데이터를 결합시키기 (merge함수)
# 기준변수 ("user_id", "app_name")
dau.install <- merge(dau, install, by = c("user_id", "app_name"))
head(dau.install)

# 1차결합된 데이터에 DPU 데이터를 결합시키기 (merge함수)
# 기준변수 (("log_date", "app_name", "user_id") 
dau.install.payment <- merge(dau.install, dpu, 
                       by = c("log_date","app_name", "user_id"), 
                       all.x = T)
head(dau.install.payment, 20)
head(na.omit(dau.install.payment))

# 비과금 유저의 과금액에 0을 넣기 ( data[row,col]<-0)
#데이터객체[is.na(데이터객체$컬럼명)] <- 0
dau.install.payment$payment[is.na(dau.install.payment$payment)] <- 0
head(dau.install.payment, 20)

# 월 항목 추가   (data.frame객체$새컬럼변수 <- 추가될 데이터, mutate, cbind 등 이용)
dau.install.payment$log_month <-substr(dau.install.payment$log_date, 1, 7)
dau.install.payment$install_month <- substr(dau.install.payment$install_date, 1, 7)
head(dau.install.payment, 20)


# 추가된 월 항목으로 그룹핑후 과금액 집계 (ddply, aggregate, dplyr::group_by등 이용)
mau.payment <- ddply(dau.install.payment,
                     .(log_month, user_id, install_month), # 그룹화
                     summarize, # 집계 명령
                     payment = sum(payment) # payment 합계
                     )

head(mau.payment, 10)


# 신규 유저인지 기존 유저인지 구분하는 항목의 새 컬럼변수 추가
mau.payment$user.type <-  ifelse(mau.payment$install_month == mau.payment$log_month, "new", "old")

# 그래프로 데이터 시각화 
library("ggplot2")

ggplot(mau.payment.summary, aes(x = log_month, 
                             y = total.payment,
                             fill = user.type)) + 
       geom_bar(stat="identity") 


















